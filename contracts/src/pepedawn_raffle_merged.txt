// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
    PepedawnRaffle — merged gold-caliber implementation
    ---------------------------------------------------
    Goals:
    - Preserve original public/external ABI where feasible to minimize frontend churn
      (functions/events retained: createRound, openRound, closeRound, placeBet,
      submitProof, snapshotRound, requestVrf, getRound, getUserStats, getRoundParticipants,
      getRoundWinners, estimateVrfCallbackGas, events incl. WagerPlaced, ProofSubmitted,
      ProofRejected, ValidProofSet, VRFRequested, VRFFulfilled, WinnersAssigned,
      FeesDistributed, ParticipantRefunded, RoundRefunded, etc.).
    - Integrate new spec features:
      * Seed-only VRF callback
      * Participants & Winners Merkle commitments (roots + CID links)
      * Winner claims with Merkle proofs (pull model)
      * Refunds & fees via pull-payments (no push loops / no external calls in callback)
      * Ticket-level semantics: an address can win multiple times up to its tickets
    - Security upgrades:
      * No external value transfers in VRF callback path
      * Pull-payments for refunds/fees (nonReentrant)
      * Denylist honored; round inputs frozen at snapshot

    NOTE: This file is intentionally written to be self-contained for review.
          In your repo wire official imports for VRF v2.5, OZ libraries, etc.
*/

import {IVRFCoordinatorV2Plus} from "@chainlink/contracts/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/vrf/dev/libraries/VRFV2PlusClient.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";

library Merkle {
    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool ok) {
        bytes32 computed = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 p = proof[i];
            computed = computed < p
                ? keccak256(abi.encodePacked(computed, p))
                : keccak256(abi.encodePacked(p, computed));
        }
        return computed == root;
    }
}

contract PepedawnRaffle is VRFConsumerBaseV2Plus, ReentrancyGuard, Pausable {
    using Merkle for bytes32[];

    // =============================================================================
    // CONSTANTS / CONFIG
    // =============================================================================
    uint256 public constant PROOF_MULTIPLIER = 1400; // +40% (x1.4 with denominator 1000)
    uint256 public constant CREATORS_FEE_PCT = 80;   // 80%
    uint256 public constant NEXT_ROUND_FEE_PCT = 20; // 20%
    uint256 public constant MIN_TICKETS_FOR_DISTRIBUTION = 10;
    uint256 public constant MAX_PARTICIPANTS_PER_ROUND = 10000;

    uint8    public constant WINNERS_PER_ROUND = 10; // for compatibility & claims

    // =============================================================================
    // STATE VARIABLES (preserved + new)
    // =============================================================================
    address public creatorsAddress;
    address public emblemVaultAddress; // kept for compatibility; prize delivery is off-chain/claims-driven

    uint256 public currentRoundId;
    uint256 public nextRoundFunds; // retained

    struct VrfConfig { address coordinator; uint256 subscriptionId; bytes32 keyHash; }
    VrfConfig public vrfConfig;

    // Security state variables
    mapping(address => bool) public denylisted;
    mapping(uint256 => mapping(address => bool)) private _winnerSelected; // legacy guard
    bool public emergencyPause;

    // Refunds & fees (pull-payments)
    mapping(address => uint256) public refunds;          // aggregated refunds per user
    uint256 public creatorFeesAccrued;                   // accrued fees for creators (pull)

    // Claims: per-user bitmap per round to prevent double-claim per prize index (0..9)
    mapping(uint256 => mapping(address => uint256)) public claimedBitmap;

    // NEW: Merkle commitments & seed per round
    struct Commitments {
        bytes32 participantsRoot;  // leaf: keccak256(abi.encode(address, uint128 weight))
        string  participantsCid;   // ipfs://...
        bytes32 winnersRoot;       // leaf: keccak256(abi.encode(address, uint8 prizeTier, uint8 prizeIndex))
        string  winnersCid;        // ipfs://...
        bytes32 vrfSeed;           // seed from VRF (randomWords[0])
    }
    mapping(uint256 => Commitments) public commitments;

    // =============================================================================
    // DATA STRUCTS (preserved)
    // =============================================================================
    enum RoundStatus {
        Created,    // Round created but not open for betting
        Open,       // Accepting bets and proofs
        Snapshotted,// Inputs frozen; participantsRoot committed
        VRFRequested, // VRF requested, waiting for fulfillment
        VRFFulfilled, // VRF fulfilled, seed stored
        WinnersCommitted, // Off-chain winners committed on-chain
        Closed,     // Round closed
        Refunded    // Round refunded due to insufficient tickets
    }

    struct Round {
        uint256 id;
        uint64 startTime;
        uint64 endTime;
        RoundStatus status;
        uint256 totalTickets;
        uint256 totalWeight;
        uint256 totalWagered;
        uint256 vrfRequestId;
        uint64 vrfRequestedAt;
        bool feesDistributed;
        uint256 participantCount; // for circuit breaker
        bytes32 validProofHash;   // set by owner
    }

    struct PuzzleProof { address wallet; uint256 roundId; bytes32 proofHash; bool verified; uint64 submittedAt; }

    struct WinnerAssignment { uint256 roundId; address wallet; uint8 prizeTier; uint256 vrfRequestId; uint256 blockNumber; }

    // Storage collections (preserved)
    mapping(uint256 => Round) public rounds;
    mapping(uint256 => mapping(address => uint256)) public userWageredInRound;
    mapping(uint256 => mapping(address => uint256)) public userTicketsInRound;
    mapping(uint256 => mapping(address => uint256)) public userWeightInRound;
    mapping(uint256 => mapping(address => bool)) public userHasProofInRound;
    mapping(uint256 => mapping(address => PuzzleProof)) public userProofInRound;
    mapping(uint256 => WinnerAssignment[]) public roundWinners; // will now be set during commitWinners
    mapping(uint256 => uint256) public vrfRequestToRound;
    mapping(uint256 => address[]) public roundParticipants;
    mapping(uint256 => mapping(address => bool)) public isParticipant;

    // =============================================================================
    // EVENTS (preserved + new)
    // =============================================================================
    event RoundCreated(uint256 indexed roundId, uint64 startTime, uint64 endTime);
    event RoundOpened(uint256 indexed roundId);
    event RoundClosed(uint256 indexed roundId);
    event RoundSnapshot(uint256 indexed roundId, uint256 totalTickets, uint256 totalWeight);

    event WagerPlaced(
        address indexed wallet,
        uint256 indexed roundId,
        uint256 amount,
        uint256 tickets,
        uint256 effectiveWeight
    );

    event ProofSubmitted(
        address indexed wallet,
        uint256 indexed roundId,
        bytes32 proofHash,
        uint256 newWeight
    );
    event ProofRejected(address indexed wallet, uint256 indexed roundId, bytes32 proofHash);
    event ValidProofSet(uint256 indexed roundId, bytes32 validProofHash);

    event VRFRequested(uint256 indexed roundId, uint256 indexed requestId);
    event VRFFulfilled(uint256 indexed roundId, uint256 indexed requestId, uint256[] randomWords);

    // Compatibility event (populated during commitWinners for UI stability)
    event WinnersAssigned(uint256 indexed roundId, address[] winners, uint8[] prizeTiers);

    // Distribution & refunds
    event PrizeDistributed(uint256 indexed roundId, address indexed winner, uint8 prizeTier, uint256 assetId);
    event FeesDistributed(uint256 indexed roundId, address indexed creators, uint256 creatorsAmount, uint256 nextRoundAmount);
    event ParticipantRefunded(uint256 indexed roundId, address indexed participant, uint256 amount);
    event RoundRefunded(uint256 indexed roundId, uint256 participantCount, uint256 totalRefunded);

    // New commitment/claim events
    event SnapshotCommitted(uint256 indexed roundId, bytes32 participantsRoot, string participantsCid);
    event WinnersCommitted(uint256 indexed roundId, bytes32 winnersRoot, string winnersCid);
    event WinnerClaimed(uint256 indexed roundId, address indexed user, uint8 prizeTier, uint8 prizeIndex);

    event EmblemVaultPrizeAssigned(uint256 indexed roundId, address indexed winner, uint8 prizeTier, uint256 indexed assetId, uint256 timestamp);
    event RoundPrizesDistributed(uint256 indexed roundId, uint256 winnerCount, uint256 timestamp);

    event AddressDenylisted(address indexed wallet, bool denylisted);
    event EmergencyPauseToggled(bool paused);
    event VRFTimeoutDetected(uint256 indexed roundId, uint256 requestId);
    event CircuitBreakerTriggered(uint256 indexed roundId, string reason);
    event SecurityValidationFailed(address indexed user, string reason);

    // =============================================================================
    // MODIFIERS
    // =============================================================================
    modifier onlyOwner() { require(msg.sender == owner(), "NOT_OWNER"); _; }
    function owner() public view returns (address) { return _owner; }
    address private _owner; // simple owner pattern; ConfirmedOwner in CL base also offers owner, but we keep explicit

    constructor(
        address _coordinator,
        uint256 _subscriptionId,
        bytes32 _keyHash,
        address _creatorsAddress,
        address _emblemVaultAddress
    ) VRFConsumerBaseV2Plus(_coordinator) {
        _owner = msg.sender;
        creatorsAddress = _creatorsAddress;
        emblemVaultAddress = _emblemVaultAddress;
        vrfConfig = VrfConfig({ coordinator: _coordinator, subscriptionId: _subscriptionId, keyHash: _keyHash });
        _createRound();
    }

    // =============================================================================
    // ADMIN / GOVERNANCE (preserved)
    // =============================================================================
    function setDenylistStatus(address wallet, bool isDenylisted) external onlyOwner { denylisted[wallet] = isDenylisted; emit AddressDenylisted(wallet, isDenylisted); }
    function setEmergencyPause(bool paused) external onlyOwner { emergencyPause = paused; if (paused) _pause(); else _unpause(); emit EmergencyPauseToggled(paused); }
    function pause() external onlyOwner { _pause(); }
    function unpause() external onlyOwner { _unpause(); }

    function updateVrfConfig(address _coordinator, uint256 _subscriptionId, bytes32 _keyHash) external onlyOwner {
        vrfConfig = VrfConfig({ coordinator: _coordinator, subscriptionId: _subscriptionId, keyHash: _keyHash });
    }

    function resetVrfTiming() external onlyOwner { /* kept for compatibility; no-op now */ }
    function updateCreatorsAddress(address _creatorsAddress) external onlyOwner { creatorsAddress = _creatorsAddress; }
    function updateEmblemVaultAddress(address _emblemVaultAddress) external onlyOwner { emblemVaultAddress = _emblemVaultAddress; }

    // =============================================================================
    // ROUND LIFECYCLE (preserved)
    // =============================================================================
    function createRound() external onlyOwner { _createRound(); }
    function _createRound() internal {
        currentRoundId += 1;
        Round storage r = rounds[currentRoundId];
        r.id = currentRoundId;
        r.startTime = uint64(block.timestamp);
        r.endTime = uint64(block.timestamp + 14 days);
        r.status = RoundStatus.Created;
        emit RoundCreated(r.id, r.startTime, r.endTime);
    }

    function setValidProof(uint256 roundId, bytes32 proofHash) external onlyOwner {
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.Created || r.status == RoundStatus.Open, "bad status");
        r.validProofHash = proofHash;
        emit ValidProofSet(roundId, proofHash);
    }

    function openRound(uint256 roundId) external onlyOwner {
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.Created, "bad status");
        r.status = RoundStatus.Open;
        emit RoundOpened(roundId);
    }

    function closeRound(uint256 roundId) external onlyOwner {
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.WinnersCommitted || r.status == RoundStatus.Refunded, "not settled");
        r.status = RoundStatus.Closed;
        emit RoundClosed(roundId);
        _createRound(); // auto-rollover as before
    }

    // =============================================================================
    // SNAPSHOT & COMMITMENTS (new while preserving old snapshotRound name)
    // =============================================================================
    function snapshotRound(uint256 roundId) external onlyOwner {
        // Backward-compatible no-arg snapshot: just freeze totals & emit legacy event; commitments set via commitParticipants()
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.Open, "bad status");
        r.status = RoundStatus.Snapshotted;
        emit RoundSnapshot(roundId, r.totalTickets, r.totalWeight);
    }

    function commitParticipants(uint256 roundId, bytes32 participantsRoot, string calldata participantsCid) external onlyOwner {
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.Snapshotted, "bad status");
        commitments[roundId].participantsRoot = participantsRoot;
        commitments[roundId].participantsCid = participantsCid;
        emit SnapshotCommitted(roundId, participantsRoot, participantsCid);
    }

    // =============================================================================
    // BETTING & PROOFS (preserved)
    // =============================================================================
    receive() external payable {}

    function placeBet(uint256 tickets) external payable whenNotPaused nonReentrant {
        require(!denylisted[msg.sender], "denied");
        Round storage r = rounds[currentRoundId];
        require(r.status == RoundStatus.Open, "not open");
        require(tickets == 1 || tickets == 5 || tickets == 10, "tickets: 1|5|10");

        uint256 pricePerTicketWei = _pricePerTicket();
        uint256 requiredAmount = tickets * pricePerTicketWei;
        require(msg.value == requiredAmount, "bad value");

        if (!isParticipant[currentRoundId][msg.sender]) {
            isParticipant[currentRoundId][msg.sender] = true;
            roundParticipants[currentRoundId].push(msg.sender);
            r.participantCount += 1;
            require(r.participantCount <= MAX_PARTICIPANTS_PER_ROUND, "too many");
        }

        userWageredInRound[currentRoundId][msg.sender] += msg.value;
        userTicketsInRound[currentRoundId][msg.sender] += tickets;
        uint256 baseAdd = tickets;
        if (userHasProofInRound[currentRoundId][msg.sender]) {
            baseAdd = (baseAdd * PROOF_MULTIPLIER) / 1000; // +40%
        }
        userWeightInRound[currentRoundId][msg.sender] += baseAdd;

        r.totalWagered += msg.value;
        r.totalTickets += tickets;
        r.totalWeight += baseAdd;

        emit WagerPlaced(msg.sender, currentRoundId, msg.value, tickets, userWeightInRound[currentRoundId][msg.sender]);
    }

    function submitProof(bytes32 proofHash) external whenNotPaused {
        Round storage r = rounds[currentRoundId];
        require(r.status == RoundStatus.Open, "not open");
        require(userWageredInRound[currentRoundId][msg.sender] > 0, "no bet");
        require(!userHasProofInRound[currentRoundId][msg.sender], "already");
        if (proofHash == r.validProofHash) {
            userHasProofInRound[currentRoundId][msg.sender] = true;
            uint256 tickets = userTicketsInRound[currentRoundId][msg.sender];
            uint256 added = (tickets * (PROOF_MULTIPLIER - 1000)) / 1000; // +40% of tickets
            userWeightInRound[currentRoundId][msg.sender] += added;
            r.totalWeight += added;
            userProofInRound[currentRoundId][msg.sender] = PuzzleProof(msg.sender, currentRoundId, proofHash, true, uint64(block.timestamp));
            emit ProofSubmitted(msg.sender, currentRoundId, proofHash, userWeightInRound[currentRoundId][msg.sender]);
        } else {
            userProofInRound[currentRoundId][msg.sender] = PuzzleProof(msg.sender, currentRoundId, proofHash, false, uint64(block.timestamp));
            emit ProofRejected(msg.sender, currentRoundId, proofHash);
        }
    }

    // =============================================================================
    // VRF REQUEST + FULFILLMENT (seed-only)
    // =============================================================================
    function requestVrf(uint256 roundId) external onlyOwner {
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.Snapshotted, "bad status");
        require(commitments[roundId].participantsRoot != bytes32(0), "no commit");

        uint256 requestId = IVRFCoordinatorV2Plus(vrfConfig.coordinator).requestRandomWords(
            vrfConfig.keyHash,
            vrfConfig.subscriptionId,
            3,              // confirmations
            200000,         // callback gas limit — minimal, seed-only
            1               // numWords = 1
        );
        r.vrfRequestId = requestId;
        vrfRequestToRound[requestId] = roundId;
        r.vrfRequestedAt = uint64(block.timestamp);
        r.status = RoundStatus.VRFRequested;
        emit VRFRequested(roundId, requestId);
    }

    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {
        uint256 roundId = vrfRequestToRound[requestId];
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.VRFRequested, "bad status");
        bytes32 seed = bytes32(randomWords[0]);
        commitments[roundId].vrfSeed = seed;
        r.status = RoundStatus.VRFFulfilled;
        emit VRFFulfilled(roundId, requestId, randomWords); // preserve original event shape
    }

    // =============================================================================
    // WINNERS COMMITMENT + CLAIMS (new)
    // =============================================================================
    function commitWinners(
        uint256 roundId,
        bytes32 winnersRoot,
        string calldata winnersCid,
        address[] calldata winners,    // compatibility: store the 10 winners for getRoundWinners/UI
        uint8[] calldata prizeTiers    // parallel array length 10
    ) external onlyOwner {
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.VRFFulfilled, "bad status");
        require(winnersRoot != bytes32(0), "root");
        require(winners.length == WINNERS_PER_ROUND && prizeTiers.length == WINNERS_PER_ROUND, "len");

        commitments[roundId].winnersRoot = winnersRoot;
        commitments[roundId].winnersCid = winnersCid;

        // Populate compatibility storage & events
        delete roundWinners[roundId];
        address[] memory ws = new address[](WINNERS_PER_ROUND);
        uint8[] memory ts = new uint8[](WINNERS_PER_ROUND);
        for (uint8 i = 0; i < WINNERS_PER_ROUND; i++) {
            roundWinners[roundId].push(WinnerAssignment({
                roundId: roundId,
                wallet: winners[i],
                prizeTier: prizeTiers[i],
                vrfRequestId: r.vrfRequestId,
                blockNumber: block.number
            }));
            ws[i] = winners[i];
            ts[i] = prizeTiers[i];
        }
        emit WinnersAssigned(roundId, ws, ts);

        r.status = RoundStatus.WinnersCommitted;
        emit WinnersCommitted(roundId, winnersRoot, winnersCid);
    }

    function claim(uint256 roundId, uint8 prizeIndex, uint8 prizeTier, bytes32[] calldata proof) external nonReentrant {
        require(prizeIndex < WINNERS_PER_ROUND, "idx");
        Round storage r = rounds[roundId];
        require(r.status == RoundStatus.WinnersCommitted || r.status == RoundStatus.Closed, "bad status");
        require(!_isClaimed(roundId, msg.sender, prizeIndex), "claimed");

        bytes32 leaf = keccak256(abi.encode(msg.sender, prizeTier, prizeIndex));
        require(Merkle.verify(proof, commitments[roundId].winnersRoot, leaf), "bad proof");

        _setClaimed(roundId, msg.sender, prizeIndex);
        emit WinnerClaimed(roundId, msg.sender, prizeTier, prizeIndex);
        // EV delivery handled off-chain or by a dedicated distributor; keep compatibility events if needed.
    }

    function _isClaimed(uint256 roundId, address user, uint8 prizeIndex) internal view returns (bool) {
        uint256 mask = (1 << prizeIndex);
        return (claimedBitmap[roundId][user] & mask) != 0;
    }
    function _setClaimed(uint256 roundId, address user, uint8 prizeIndex) internal {
        uint256 mask = (1 << prizeIndex);
        claimedBitmap[roundId][user] |= mask;
    }

    // =============================================================================
    // REFUNDS & FEES (pull-payments)
    // =============================================================================
    function _refundParticipants(uint256 roundId) internal {
        // Modified: accrue refunds instead of pushing ETH transfers
        Round storage r = rounds[roundId];
        address[] memory participants = roundParticipants[roundId];
        uint256 totalRefunded = 0;
        for (uint256 i = 0; i < participants.length; i++) {
            address participant = participants[i];
            uint256 refundAmount = userWageredInRound[roundId][participant];
            if (refundAmount > 0) {
                // reset per-round user tallies
                userWageredInRound[roundId][participant] = 0;
                userTicketsInRound[roundId][participant] = 0;
                userWeightInRound[roundId][participant] = 0;
                refunds[participant] += refundAmount; // accrue
                totalRefunded += refundAmount;
                emit ParticipantRefunded(roundId, participant, refundAmount);
            }
        }
        r.status = RoundStatus.Refunded;
        emit RoundRefunded(roundId, participants.length, totalRefunded);
    }

    function withdrawRefund() external nonReentrant {
        uint256 amt = refunds[msg.sender];
        require(amt > 0, "none");
        refunds[msg.sender] = 0;
        (bool ok, ) = msg.sender.call{value: amt}("");
        require(ok, "xfer");
    }

    function _distributeFees(uint256 roundId) internal {
        Round storage round = rounds[roundId];
        if (round.feesDistributed) return;
        uint256 totalFees = round.totalWagered;
        uint256 creatorsAmount = (totalFees * CREATORS_FEE_PCT) / 100;
        uint256 nextRoundAmount = (totalFees * NEXT_ROUND_FEE_PCT) / 100;
        require(creatorsAmount + nextRoundAmount <= totalFees, "fee math");
        require(creatorsAddress != address(0), "creators");
        round.feesDistributed = true;
        nextRoundFunds += nextRoundAmount;
        creatorFeesAccrued += creatorsAmount; // pull later
        emit FeesDistributed(roundId, creatorsAddress, creatorsAmount, nextRoundAmount);
    }

    function withdrawCreatorFees(address payable to, uint256 amount) external onlyOwner nonReentrant {
        require(to != address(0) && amount > 0 && amount <= creatorFeesAccrued, "bad");
        creatorFeesAccrued -= amount;
        (bool ok, ) = to.call{value: amount}("");
        require(ok, "xfer");
    }

    // =============================================================================
    // LEGACY HELPERS (retained public views)
    // =============================================================================
    function getRound(uint256 roundId) external view returns (
        uint256 id, uint64 startTime, uint64 endTime, RoundStatus status, uint256 totalTickets, uint256 totalWeight,
        uint256 totalWagered, uint256 vrfRequestId, uint64 vrfRequestedAt, bool feesDistributed, uint256 participantCount,
        bytes32 validProofHash
    ) {
        Round storage r = rounds[roundId];
        return (r.id, r.startTime, r.endTime, r.status, r.totalTickets, r.totalWeight, r.totalWagered, r.vrfRequestId, r.vrfRequestedAt, r.feesDistributed, r.participantCount, r.validProofHash);
    }

    function getUserStats(uint256 roundId, address user) external view returns (uint256 wagered, uint256 tickets, uint256 weight, bool hasProof) {
        return (userWageredInRound[roundId][user], userTicketsInRound[roundId][user], userWeightInRound[roundId][user], userHasProofInRound[roundId][user]);
    }

    function getRoundParticipants(uint256 roundId) external view returns (address[] memory) { return roundParticipants[roundId]; }

    function getRoundWinners(uint256 roundId) external view returns (WinnerAssignment[] memory) { return roundWinners[roundId]; }

    function estimateVrfCallbackGas(uint256 /*roundId*/) external pure returns (uint256) { return 150_000; } // seed-only

    // =============================================================================
    // INTERNAL PRICING (placeholder to match original expectations)
    // =============================================================================
    function _pricePerTicket() internal pure returns (uint256) {
        // Match original economics (example): 0.005 ETH/ticket with bundle discounts applied off-chain at call site
        return 0.005 ether;
    }
}
